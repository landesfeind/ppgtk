%h{
#include <ppgtk/ppgtk.h>
%}

class PPGtk:Presenter from Gtk:Application:Window {

	private Gtk:Widget *filechooser = NULL
		unrefwith g_object_unref;
	
	/**
	  * The file from which the document is loaded and displayed.
	  * Should be set when constructing the presenter. If not given,
	  * the presenter will just show blank data.
	  */
	private G:File *file = NULL
		unrefwith g_object_unref;
	property OBJECT file (
				nick = _("File"),
				object_type = G:File,
				export, link);

	/**
	  * An object to access the document.
	  */
	private Poppler:Document *document = NULL
		unrefwith g_object_unref;

	private Gtk:Drawing:Area *draw_current = { (GtkDrawingArea *)gtk_drawing_area_new(); };
	private Gtk:Drawing:Area *draw_next    = { (GtkDrawingArea *)gtk_drawing_area_new(); };
	private Gtk:Drawing:Area *draw_counter = { (GtkDrawingArea *)gtk_drawing_area_new(); };

	private Gtk:Button *button_prev = { (GtkButton *)gtk_button_new() };
	private Gtk:Button *button_next = { (GtkButton *)gtk_button_new() };
	private Gtk:Toggle:Button *tbutton_freeze = { (GtkToggleButton *)gtk_toggle_button_new_with_mnemonic(_("_Freeze")) };
	private Gtk:Toggle:Button *tbutton_blank  = { (GtkToggleButton *)gtk_toggle_button_new_with_mnemonic(_("_Blank")) };

	private gint slide = 0;
	property INT slide (
				nick = "Current slide",
				default_value = 0,
				minimum = 0,
				export)
		set {
			gint index = g_value_get_int(VAL);
			if( ! selfp->document ){
				index = 0;
			}
			else if( index >= poppler_document_get_n_pages(selfp->document) ){
				index = poppler_document_get_n_pages(selfp->document) - 1;
			}
			selfp->slide = index;
		}
		get { 
			g_value_set_int(VAL, selfp->slide); 
		};


	constructor(self){
		gtk_window_set_title(GTK_WINDOW(self), PPGTK_NAME);

		GtkGrid *grid = (GtkGrid *)gtk_grid_new();
		gtk_container_add(GTK_CONTAINER(self), GTK_WIDGET(grid));

		GtkGrid *button_grid = (GtkGrid *)gtk_grid_new();

		gtk_grid_attach(grid, GTK_WIDGET(selfp->draw_current), 0, 0, 1, 2);
		gtk_grid_attach(grid, GTK_WIDGET(selfp->draw_next   ), 1, 0, 1, 1);
		gtk_grid_attach(grid, GTK_WIDGET(selfp->draw_counter), 1, 1, 1, 1);
		gtk_grid_attach(grid, GTK_WIDGET(button_grid        ), 0, 2, 2, 1);

		gtk_widget_set_size_request(GTK_WIDGET(selfp->draw_current), 300, 300);
		g_object_set(G_OBJECT(selfp->draw_current), "hexpand", TRUE, "vexpand", TRUE, "margin-right", 1, NULL);
		gtk_widget_set_size_request(GTK_WIDGET(selfp->draw_next), 100, 100);
		g_object_set(G_OBJECT(selfp->draw_next), "hexpand", TRUE, "vexpand", TRUE, "margin-bottom", 1, NULL);
		gtk_widget_set_size_request(GTK_WIDGET(selfp->draw_counter), 100, 50);
		g_object_set(G_OBJECT(selfp->draw_counter), "hexpand", FALSE, "vexpand", TRUE, NULL);

		gtk_grid_attach(button_grid, GTK_WIDGET(selfp->button_prev   ), 0, 0, 1, 1);
		gtk_grid_attach(button_grid, GTK_WIDGET(selfp->tbutton_freeze), 1, 0, 1, 1);
		gtk_grid_attach(button_grid, GTK_WIDGET(selfp->tbutton_blank ), 2, 0, 1, 1);
		gtk_grid_attach(button_grid, GTK_WIDGET(selfp->button_next   ), 3, 0, 1, 1);

		g_object_set(G_OBJECT(button_grid       ), "margin-top", 1, NULL);
		g_object_set(G_OBJECT(selfp->button_prev   ), "hexpand", FALSE, "vexpand", TRUE, NULL);
		g_object_set(G_OBJECT(selfp->tbutton_freeze), "hexpand", TRUE, "vexpand", TRUE, "margin-right", 1, NULL);
		g_object_set(G_OBJECT(selfp->tbutton_blank ), "hexpand", TRUE, "vexpand", TRUE, "margin-right", 1, NULL);
		g_object_set(G_OBJECT(selfp->button_next   ), "hexpand", FALSE, "vexpand", TRUE, "margin-right", 1, NULL);

		gtk_container_add(GTK_CONTAINER(selfp->button_prev), gtk_image_new_from_icon_name("previous", GTK_ICON_SIZE_BUTTON));
		gtk_container_add(GTK_CONTAINER(selfp->button_next), gtk_image_new_from_icon_name("forward", GTK_ICON_SIZE_BUTTON));

		gtk_actionable_set_action_name(GTK_ACTIONABLE(selfp->button_prev), "win.previous");
		gtk_actionable_set_action_name(GTK_ACTIONABLE(selfp->button_next), "win.next");

		g_signal_connect(G_OBJECT(selfp->draw_current), "draw", G_CALLBACK(&self_on_draw_current), self);
		g_signal_connect(G_OBJECT(selfp->draw_next   ), "draw", G_CALLBACK(&self_on_draw_next), self);
		g_signal_connect(G_OBJECT(selfp->draw_counter), "draw", G_CALLBACK(&self_on_draw_counter), self);
		g_signal_connect(G_OBJECT(self), "notify::slide", G_CALLBACK(&self_on_notify_slide), NULL);
		g_signal_connect(G_OBJECT(self), "notify::file", G_CALLBACK(&self_on_notify_file), NULL);
	}

	dispose(self){
		gchar *f = selfp->file ? g_file_get_path(selfp->file) : NULL;
		g_debug("Disposing window to display: %s", f);
		if(f)
			g_free(f);
	}

	private void init_actions(self){
		GSimpleAction *action = NULL;

		action = g_simple_action_new("open", NULL);
		g_signal_connect(G_OBJECT(action), "activate", G_CALLBACK(self_on_action_open), self);
		g_simple_action_set_enabled(action, TRUE);
		g_action_map_add_action(G_ACTION_MAP(self), G_ACTION(action));

		action = g_simple_action_new("open-new", NULL);
		g_signal_connect(G_OBJECT(action), "activate", G_CALLBACK(self_on_action_open_new_window), self);
		g_simple_action_set_enabled(action, TRUE);
		g_action_map_add_action(G_ACTION_MAP(self), G_ACTION(action));

		action = g_simple_action_new("close", NULL);
		g_signal_connect(G_OBJECT(action), "activate", G_CALLBACK(self_on_action_close), self);
		g_simple_action_set_enabled(action, TRUE);
		g_action_map_add_action(G_ACTION_MAP(self), G_ACTION(action));

		action = g_simple_action_new("next", NULL);
		g_signal_connect(G_OBJECT(action), "activate", G_CALLBACK(self_on_action_next), self);
		g_simple_action_set_enabled(action, TRUE);
		g_action_map_add_action(G_ACTION_MAP(self), G_ACTION(action));

		action = g_simple_action_new("previous", NULL);
		g_signal_connect(G_OBJECT(action), "activate", G_CALLBACK(self_on_action_previous), self);
		g_simple_action_set_enabled(action, TRUE);
		g_action_map_add_action(G_ACTION_MAP(self), G_ACTION(action));

		action = g_simple_action_new("about", NULL);
		g_signal_connect(G_OBJECT(action), "activate", G_CALLBACK(self_on_action_about), self);
		g_simple_action_set_enabled(action, TRUE);
		g_action_map_add_action(G_ACTION_MAP(self), G_ACTION(action));
	}

	public PPGtkPresenter *new(Gtk:Application *app){
		return self_new_with_file(app, NULL);
	}

	public PPGtkPresenter *new_with_file(Gtk:Application *app (check null type), G:File *pdf_file (check type)){
		return GET_NEW_VARG("file", pdf_file, "application", app, NULL);
	}

	public void reset(self){
		if( selfp->document )
			g_object_unref(selfp->document);
		selfp->document = NULL;
		gtk_widget_queue_draw(GTK_WIDGET(self));
	}

	public void redraw_slides(self){
		// Only re-draw sub-widgets because the main part does not need to be redrawn
		gtk_widget_queue_draw(GTK_WIDGET(selfp->draw_current));
		gtk_widget_queue_draw(GTK_WIDGET(selfp->draw_next   ));
		gtk_widget_queue_draw(GTK_WIDGET(selfp->draw_counter));
	}

	private void _draw_frame(Gtk:Widget *w, cairo_t *cr, gdouble r, gdouble g, gdouble b){
		cairo_save(cr);
		gdouble widget_width  = (gdouble)gtk_widget_get_allocated_width(w);
		gdouble widget_height = (gdouble)gtk_widget_get_allocated_height(w);
		cairo_move_to(cr, 0, 0);
		cairo_line_to(cr, widget_width, 0 );
		cairo_line_to(cr, widget_width, widget_height);
		cairo_line_to(cr, 0, widget_height);
		cairo_close_path(cr);
		cairo_set_source_rgba(cr, r, g, b, 1);
		cairo_stroke(cr);
		cairo_restore(cr);

	}
	/** Draws a specific slide to the given widget and corresponding cairo context **/
	private gboolean draw_slide_to(self, Gtk:Widget *w (check null type), cairo_t *cr (check null), gint slide (check >= 0)){
		// Ensure that a document is opened
		self_ensure_document(self);
		self__draw_frame(w, cr, 1, 0, 0);

		gdouble widget_width  = (gdouble)gtk_widget_get_allocated_width(w);
		gdouble widget_height = (gdouble)gtk_widget_get_allocated_height(w);

		// Check for probable errors
		gchar *text = NULL;
		if( ! selfp->document ){
			text = _("Load a document first");
		}
		else if( slide >= poppler_document_get_n_pages(selfp->document) ){
			text = _("Presentation finished");
		}
		
		if( text ){
			cairo_text_extents_t extents;
			cairo_text_extents(cr, text, &extents);
			cairo_move_to(cr, 
					widget_width  - (extents.width/2 + extents.x_bearing),
					widget_height - (extents.height/2 + extents.y_bearing) );
			cairo_show_text(cr, text);
			return TRUE;
		}

		gdouble width, height;
		PopplerPage *p = poppler_document_get_page(selfp->document, slide);
		if( ! p ){
			g_warning("Can not get document page %d", slide);
			return FALSE;
		}
		poppler_page_get_size(p, &width, &height);

		gdouble scale_x = widget_width  / width;
		gdouble scale_y = widget_height / height;
		gdouble scale_min = scale_x < scale_y ? scale_x : scale_y;

		cairo_scale(cr, scale_min, scale_min);
		poppler_page_render(p, cr);

		return TRUE;
	}

	/** Callback for draw signal of the Gtk:Drawing:Area displaying the current slide. */
	private gboolean on_draw_current(GtkWidget *w, cairo_t *cr, gpointer data){
		Self *self = SELF(data);
		//g_debug("Drawing slide %d to the current-display", selfp->slide);
		return self_draw_slide_to(self, w, cr, selfp->slide);
	}

	/** Callback for draw signal of the Gtk:Drawing:Area displaying the next slide. **/
	private gboolean on_draw_next(GtkWidget *w, cairo_t *cr, gpointer data){
		Self *self = SELF(data);
		//g_debug("Drawing slide %d to the next-display", selfp->slide + 1);
		return self_draw_slide_to(self, w, cr, selfp->slide + 1);
	}
	
	private gboolean on_draw_counter(GtkWidget *w, cairo_t *cr, gpointer data){
		gchar buffer[25];
		Self *self = SELF(data);
		self_ensure_document(self);
		self__draw_frame(w, cr, 0, 1, 0);

		if( ! selfp->document )
			return TRUE;

		gdouble widget_width  = (gdouble)gtk_widget_get_allocated_width(w);
		gdouble widget_height = (gdouble)gtk_widget_get_allocated_height(w);
		
		gint text_width, text_height;

		sprintf(buffer, "%d / %d", selfp->slide, poppler_document_get_n_pages(selfp->document));
		//g_debug("Display page counter: '%s'", buffer);
		PangoLayout *layout = pango_cairo_create_layout(cr);
		pango_layout_set_text(layout, buffer, -1);
		pango_layout_get_size(layout, &text_width, &text_height);

		text_width  /= PANGO_SCALE;
		text_height /= PANGO_SCALE;

		gdouble scalew = widget_width / text_width ;
		gdouble scaleh = widget_height / text_height;
		gdouble scale = scalew < scaleh ? scalew : scaleh;
		cairo_move_to(cr, widget_width - text_width, 0);
		//cairo_scale(cr, scale, scale);
		pango_cairo_show_layout(cr, layout);

		g_object_unref(layout);
		return TRUE;
	}

	/** Notify callback when the slide parameter of the presenter changes. **/
	private void on_notify_slide(G:Object *s, G:Param:Spec *pspec, gpointer data){
		PPGTK_UNUSED(pspec);
		PPGTK_UNUSED(data);
		self_redraw_slides(SELF(s));
	}

	/** Notify callback when the file changes **/
	private void on_notify_file(G:Object *s, G:Param:Spec *pspec, gpointer data){
		PPGTK_UNUSED(pspec);
		PPGTK_UNUSED(data);
		Self *self = SELF(s);
		self_reset(self);
	}

	/** Action callback when the "close" action is activated **/
	private void on_action_close(G:Action *a, G:Variant *param, gpointer data){
		PPGTK_UNUSED(a);
		PPGTK_UNUSED(param);
		if( GTK_IS_WINDOW(data) )
			gtk_widget_destroy(GTK_WIDGET(data));
	}


	/**
	  * Action callback to move to the previous slide.
	  */
	private void on_action_previous(G:Action *a, G:Variant *param, gpointer data){
		PPGTK_UNUSED(a);
		PPGTK_UNUSED(param);
		Self *self = SELF(data);
		if( selfp->slide > 0 )
			return;
		
		self_set_slide(self, self_get_slide(self) - 1 );
	}

	/**
	  * Action callback to move to the next slide.
	  */
	private void on_action_next(G:Action *a, G:Variant *param, gpointer data){
		PPGTK_UNUSED(a);
		PPGTK_UNUSED(param);
		Self *self = SELF(data);
		if( selfp->slide + 1 >= poppler_document_get_n_pages(selfp->document) )
			return;
		self_set_slide(self, self_get_slide(self) + 1 );
	}

	/**
	  * Action callback to show an about dialog.
	  */
	private void on_action_about(G:Action *a, G:Variant *param, gpointer data){
		PPGTK_UNUSED(a);
		PPGTK_UNUSED(param);
		Self *self = SELF(data);

		GtkWidget *dialog = gtk_about_dialog_new();
		gtk_widget_set_parent(GTK_WIDGET(dialog), GTK_WIDGET(self));
		gtk_about_dialog_set_program_name(GTK_ABOUT_DIALOG(dialog), PPGTK_NAME);
		gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(dialog), "PPGTK_VERSION_MAJOR.PPGTK_VERSION_MINOR.PPGTK_VERSION_PATCH");
		gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(dialog), _("Copyright 2014"));
		gtk_about_dialog_set_license_type(GTK_ABOUT_DIALOG(dialog), GTK_LICENSE_GPL_3_0);
		gtk_about_dialog_set_website(GTK_ABOUT_DIALOG(dialog), "http://www.github.de/landesfeind/ppgtk");

		//gchar *authors[] = (gchar *[]){ PPGTK_AUTHOR, NULL };
		//gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(dialog), authors);

		gtk_dialog_run(GTK_DIALOG(dialog));
		gtk_widget_destroy(GTK_WIDGET(dialog));
	}

	private void on_action_open(G:Simple:Action *a, G:Variant *v, gpointer data){
		PPGTK_UNUSED(a);
		PPGTK_UNUSED(v);
		self_open_file(SELF(data), FALSE);
	}

	private void on_action_open_new_window(G:Simple:Action *a, G:Variant *v, gpointer data){
		PPGTK_UNUSED(a);
		PPGTK_UNUSED(v);
		self_open_file(SELF(data), TRUE);
	}

	/**
	  * Display a message dialog that is modal for the PPGtk:Presenter window.
	  */
	private void display_message(self, GtkMessageType type, const gchar *msg, va_list vl){
		GString *message = g_string_new(NULL);
		g_string_vprintf(message, msg, vl);

		GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(self), 
					GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT, 
					type, 
					GTK_BUTTONS_OK,
					message->str);
		gtk_widget_show_all(GTK_WIDGET(dialog));
		gtk_dialog_run(GTK_DIALOG(dialog));
		gtk_widget_destroy(GTK_WIDGET(dialog));
	}

	/**
	  * Displays an error message. 
	  * @see ppgtk_presenter_display_message
	  */
	public void display_error(self, const gchar *msg, ...){
		va_list vl;
		va_start(vl, msg);
		self_display_message(self, GTK_MESSAGE_ERROR, msg, vl);
		va_end(vl);
	}

	/**
	  * Displays an informational message. 
	  * @see ppgtk_presenter_display_message
	  */
	public void display_info(self, const gchar *msg, ...){
		va_list vl;
		va_start(vl, msg);
		self_display_message(self, GTK_MESSAGE_INFO, msg, vl);
		va_end(vl);
	}

	/**
	  * Tries to open the file and to load the poppler object.
	  * Returns true when the file is successfully opened. 
	  */
	private gboolean ensure_document(self){
		if( selfp->document )
			return TRUE;

		if( ! selfp->file )
			return FALSE;

		if( ! g_file_query_exists(selfp->file, NULL) ){
			self_display_error(self, _("File does not exist"));
			return FALSE;
		}

		if( g_file_query_file_type(selfp->file, G_FILE_QUERY_INFO_NONE, NULL) != G_FILE_TYPE_REGULAR ){
			self_display_error(self, _("Not a regular file"));
			return FALSE;
		}

		GError *error = NULL;
		gchar *file = g_file_get_uri(selfp->file);
		selfp->document = poppler_document_new_from_file(file, NULL, &error);
		g_free(file);
		if( error ){
			g_error(error->message);
			self_display_error(self, error->message);
			return FALSE;
		}
		if( ! selfp->document ){
			self_display_error(self, _("Can not open document for unkown reason"));
			return FALSE;
		}
		
		g_debug("Displaying document with %d slides", poppler_document_get_n_pages(selfp->document));
		
		// Make title
		gchar *title = poppler_document_get_title(selfp->document);
		GString *titlen = g_string_new(title);
		g_string_append(titlen, " - ");
		g_string_append(titlen, PPGTK_NAME);
		gtk_window_set_title(GTK_WINDOW(self), titlen->str);
		g_string_free(titlen, TRUE);
		g_free(title);
		return TRUE;
	}



	public void open_file(self, gboolean new_window){
		if( ! selfp->filechooser ){
			selfp->filechooser = gtk_file_chooser_dialog_new(_("Open PDF Presentation"),
				NULL, GTK_FILE_CHOOSER_ACTION_OPEN,
				_("Cancel"), GTK_RESPONSE_CANCEL,
				_("Open"), GTK_RESPONSE_ACCEPT,
				NULL);

			gtk_file_chooser_set_local_only(GTK_FILE_CHOOSER(selfp->filechooser), TRUE);
			gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(selfp->filechooser), TRUE);

			GtkFileFilter *ff = gtk_file_filter_new();
			gtk_file_filter_set_name(ff, "Portable Document Format (*.pdf)");
			gtk_file_filter_add_mime_type(ff, "application/pdf");
			gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(selfp->filechooser), ff);

			g_object_ref(selfp->filechooser);
		}

		g_debug("Running file chooser dialog to open PDF");
		gint res = gtk_dialog_run(GTK_DIALOG(selfp->filechooser));
		if( res != GTK_RESPONSE_ACCEPT )
			return;

		GSList *list = gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(selfp->filechooser));
		if( ! list )
			return;
		g_debug("Running file chooser dialog returned with %d files", (gint)g_slist_length(list));

		for(guint i = 0; i < g_slist_length(list); i++){
			gpointer data = g_slist_nth_data(list, i);
			if( data && G_IS_FILE(data) )
				self_open_file_single(self, G_FILE(data), new_window);
		}

		g_slist_free_full(list, g_free);
	}
	
	public void open_file_single(self, G:File *file (check null type), gboolean new_window){
		g_debug("Opening %swindow to show document %s", new_window ? "new " : "", g_file_get_path(file));

		if( new_window ){ 
			GtkApplication *app = gtk_window_get_application(GTK_WINDOW(self));
			Self *window = self_new_with_file(app, file);
			gtk_widget_show_all(GTK_WIDGET(window));
			gtk_application_add_window(GTK_APPLICATION(self), GTK_WINDOW(window));
		}
		else {
			self_set_file(self, G_OBJECT(file));
		}
	}
}
